
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bruno-api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bruno-api/main.go (0.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "crypto/md5"
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "regexp"
        "strings"
        "sync"
        "time"

        // üåê Web framework and middleware
        "github.com/gin-contrib/cors"
        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/otel"

        // üîß Environment and database
        "github.com/joho/godotenv"
        "github.com/lib/pq"
        _ "github.com/lib/pq"

        // üìä Prometheus monitoring
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        // üóÑÔ∏è Redis caching
        "github.com/redis/go-redis/v9"
        // üîç OpenTelemetry tracing - DISABLED
        // "go.opentelemetry.io/otel"
        // "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        // "go.opentelemetry.io/otel/sdk/resource"
        // sdktrace "go.opentelemetry.io/otel/sdk/trace"
        // semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// =============================================================================
// üìã DATA STRUCTURES
// =============================================================================

// üéØ Project represents a project
type Project struct {
        ID               int      `json:"id"`
        Title            string   `json:"title"`
        Description      string   `json:"description"`
        ShortDescription string   `json:"short_description"`
        Type             string   `json:"type"`
        Modules          int      `json:"modules"`
        Icon             string   `json:"icon"`
        URL              string   `json:"url"`
        VideoURL         string   `json:"video_url,omitempty"`
        Technologies     []string `json:"technologies"`
        Active           bool     `json:"active"` // Controls visibility
}

// üìÑ Content represents dynamic content from database
type Content struct {
        ID    int    `json:"id"`
        Type  string `json:"type"`
        Value string `json:"value"`
}

// üë§ AboutData represents about page information
type AboutData struct {
        Description string `json:"description"`
        Highlights  []struct {
                Icon string `json:"icon"`
                Text string `json:"text"`
        } `json:"highlights"`
}

// üìû ContactData represents contact information
type ContactData struct {
        Email        string `json:"email"`
        Location     string `json:"location"`
        LinkedIn     string `json:"linkedin"`
        GitHub       string `json:"github"`
        Availability string `json:"availability"`
}

// üõ†Ô∏è Skill represents a technical skill
type Skill struct {
        ID          int    `json:"id"`
        Name        string `json:"name"`
        Category    string `json:"category"`
        Proficiency int    `json:"proficiency"`
        Icon        string `json:"icon"`
        Order       int    `json:"order"`
}

// üíº Experience represents work experience
type Experience struct {
        ID           int      `json:"id"`
        Title        string   `json:"title"`
        Company      string   `json:"company"`
        StartDate    string   `json:"start_date"`
        EndDate      *string  `json:"end_date"`
        Current      bool     `json:"current"`
        Description  string   `json:"description"`
        Technologies []string `json:"technologies"`
        Order        int      `json:"order"`
}

// =============================================================================
// üåç GLOBAL VARIABLES
// =============================================================================

var (
        // üóÑÔ∏è Database and Redis connections
        db  *sql.DB
        rdb *redis.Client

        // üö¶ Rate limiting
        rateLimitMap   = make(map[string][]time.Time)
        rateLimitMutex sync.RWMutex

        // üìä Prometheus metrics
        httpRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"path", "method", "status"},
        )
        httpRequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"path", "method", "status"},
        )

        // üîç Validation patterns
        urlPattern   = regexp.MustCompile(`^https?://[^\s/$.?#].[^\s]*$`)
        emailPattern = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
)

// =============================================================================
// üöÄ INITIALIZATION
// =============================================================================

func init() <span class="cov8" title="1">{
        // üìä Register Prometheus metrics
        prometheus.MustRegister(httpRequestsTotal, httpRequestDuration)
}</span>

// =============================================================================
// üóÑÔ∏è CACHE HELPERS (Redis Operations)
// =============================================================================

// getFromCache retrieves data from Redis cache with type safety
func getFromCache[T any](ctx context.Context, key string) (T, bool) <span class="cov0" title="0">{
        var result T
        if rdb == nil </span><span class="cov0" title="0">{
                return result, false
        }</span>

        <span class="cov0" title="0">cached, err := rdb.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return result, false
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(cached), &amp;result); err != nil </span><span class="cov0" title="0">{
                return result, false
        }</span>

        <span class="cov0" title="0">return result, true</span>
}

// setCache stores data in Redis cache with duration
func setCache(ctx context.Context, key string, data interface{}, duration time.Duration) <span class="cov0" title="0">{
        if rdb == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if dataBytes, err := json.Marshal(data); err == nil </span><span class="cov0" title="0">{
                rdb.Set(ctx, key, dataBytes, duration)
        }</span>
}

// clearCache removes data from Redis cache
func clearCache(ctx context.Context, key string) <span class="cov0" title="0">{
        if rdb != nil </span><span class="cov0" title="0">{
                rdb.Del(ctx, key)
        }</span>
}

// =============================================================================
// üóÉÔ∏è DATABASE HELPERS (with tracing)
// =============================================================================

// queryRowWithTracing executes a single row query with OpenTelemetry tracing - DISABLED
func queryRowWithTracing(ctx context.Context, tracerName, queryName, query string, dest ...interface{}) error <span class="cov0" title="0">{
        // tracer := otel.Tracer(tracerName)
        // _, span := tracer.Start(ctx, fmt.Sprintf("db.query.%s", queryName))
        // defer span.End()

        err := db.QueryRowContext(ctx, query, dest...).Scan(dest...)
        // if err != nil {
        //         span.RecordError(err)
        // }
        return err
}</span>

// execWithTracing executes a database statement with OpenTelemetry tracing - DISABLED
func execWithTracing(ctx context.Context, tracerName, queryName, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        // tracer := otel.Tracer(tracerName)
        // _, span := tracer.Start(ctx, fmt.Sprintf("db.exec.%s", queryName))
        // defer span.End()

        result, err := db.ExecContext(ctx, query, args...)
        // if err != nil {
        //         span.RecordError(err)
        // }
        return result, err
}</span>

// =============================================================================
// üåê HTTP RESPONSE HELPERS
// =============================================================================

// respondWithETag sends response with ETag for caching
func respondWithETag(c *gin.Context, data interface{}, status int) <span class="cov0" title="0">{
        etag := generateETag(data)
        if c.GetHeader("If-None-Match") == etag </span><span class="cov0" title="0">{
                c.Status(http.StatusNotModified)
                return
        }</span>
        <span class="cov0" title="0">c.Header("ETag", etag)
        c.JSON(status, data)</span>
}

// respondWithError sends standardized error response
func respondWithError(c *gin.Context, status int, message string) <span class="cov0" title="0">{
        c.JSON(status, gin.H{"error": message})
}</span>

// respondWithSuccess sends standardized success response
func respondWithSuccess(c *gin.Context, data interface{}) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, data)
}</span>

// =============================================================================
// üîß UTILITY FUNCTIONS
// =============================================================================

// getEnv gets environment variable with fallback
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// generateETag creates MD5 hash for ETag
func generateETag(data interface{}) string <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">hash := md5.Sum(jsonData)
        return fmt.Sprintf("\"%x\"", hash)</span>
}

// getContentValue retrieves content from database with fallback
func getContentValue(ctx context.Context, key, field, defaultValue string) string <span class="cov0" title="0">{
        var value string
        query := fmt.Sprintf("SELECT value-&gt;&gt;'%s' FROM content WHERE key = $1", field)
        err := db.QueryRowContext(ctx, query, key).Scan(&amp;value)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}

// validateURL validates URL format
func validateURL(url string) bool <span class="cov0" title="0">{
        return urlPattern.MatchString(url)
}</span>

// validateEmail validates email format
func validateEmail(email string) bool <span class="cov0" title="0">{
        return emailPattern.MatchString(email)
}</span>

// sanitizeString removes potentially dangerous content
func sanitizeString(input string) string <span class="cov0" title="0">{
        dangerous := []string{"&lt;script&gt;", "&lt;/script&gt;", "javascript:", "onload=", "onerror="}
        result := input
        for _, danger := range dangerous </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, danger, "")
        }</span>
        <span class="cov0" title="0">return result</span>
}

// isValidIP validates IP address format
func isValidIP(ip string) bool <span class="cov0" title="0">{
        if ip == "localhost" || ip == "127.0.0.1" || ip == "::1" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">parts := strings.Split(ip, ".")
        if len(parts) == 4 </span><span class="cov0" title="0">{
                for _, part := range parts </span><span class="cov0" title="0">{
                        if len(part) == 0 || len(part) &gt; 3 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">for _, char := range part </span><span class="cov0" title="0">{
                                if char &lt; '0' || char &gt; '9' </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                        <span class="cov0" title="0">num := 0
                        for _, char := range part </span><span class="cov0" title="0">{
                                num = num*10 + int(char-'0')
                        }</span>
                        <span class="cov0" title="0">if num &gt; 255 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if part[0] == '0' &amp;&amp; len(part) &gt; 1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// countActiveProjects counts active projects
func countActiveProjects(projects []Project) int <span class="cov0" title="0">{
        count := 0
        for _, p := range projects </span><span class="cov0" title="0">{
                if p.Active </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// countInactiveProjects counts inactive projects
func countInactiveProjects(projects []Project) int <span class="cov0" title="0">{
        count := 0
        for _, p := range projects </span><span class="cov0" title="0">{
                if !p.Active </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// =============================================================================
// üîç OPEN TELEMETRY SETUP
// =============================================================================

// initTracer sets up OpenTelemetry tracing - DISABLED
func initTracer() (interface{}, error) <span class="cov0" title="0">{
        // exporter, err := otlptracegrpc.New(context.Background(),
        //         otlptracegrpc.WithEndpoint("localhost:4317"),
        //         otlptracegrpc.WithInsecure(),
        // )
        // if err != nil {
        //         return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        // }

        // res, err := resource.New(context.Background(),
        //         resource.WithAttributes(
        //                 semconv.ServiceName("bruno-api"),
        //                 semconv.ServiceVersion("1.0.0"),
        //         ),
        // )
        // if err != nil {
        //         return nil, fmt.Errorf("failed to create resource: %w", err)
        // }

        // tp := sdktrace.NewTracerProvider(
        //         sdktrace.WithBatcher(exporter),
        //         sdktrace.WithResource(res),
        // )

        // otel.SetTracerProvider(tp)
        // return tp, nil
        return nil, nil
}</span>

// =============================================================================
// üóÑÔ∏è DATABASE &amp; REDIS INITIALIZATION
// =============================================================================

// initDB initializes database connection
func initDB() <span class="cov0" title="0">{
        dbURL := os.Getenv("DATABASE_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                // üîß Fallback to individual environment variables
                dbHost := getEnv("DB_HOST", "localhost")
                dbPort := getEnv("DB_PORT", "5432")
                dbUser := getEnv("DB_USER", "bruno_user")
                dbPassword := getEnv("DB_PASSWORD", "bruno_password")
                dbName := getEnv("DB_NAME", "bruno_site")

                dbURL = fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                        dbHost, dbPort, dbUser, dbPassword, dbName)
        }</span>

        <span class="cov0" title="0">var err error
        db, err = sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("‚ùå Failed to connect to database:", err)
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("‚ùå Failed to ping database:", err)
        }</span>

        <span class="cov0" title="0">log.Println("‚úÖ Successfully connected to database")</span>
}

// initRedis initializes Redis connection
func initRedis() <span class="cov0" title="0">{
        redisURL := os.Getenv("REDIS_URL")
        if redisURL == "" </span><span class="cov0" title="0">{
                // üîß Fallback to individual environment variables
                redisHost := getEnv("REDIS_HOST", "localhost")
                redisPort := getEnv("REDIS_PORT", "6379")
                redisPassword := getEnv("REDIS_PASSWORD", "")

                if redisPassword != "" </span><span class="cov0" title="0">{
                        redisURL = fmt.Sprintf("redis://:%s@%s:%s", redisPassword, redisHost, redisPort)
                }</span> else<span class="cov0" title="0"> {
                        redisURL = fmt.Sprintf("redis://%s:%s", redisHost, redisPort)
                }</span>
        }

        <span class="cov0" title="0">opt, err := redis.ParseURL(redisURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ö†Ô∏è Failed to parse Redis URL: %v, continuing without Redis", err)
                rdb = nil
                return
        }</span>

        <span class="cov0" title="0">rdb = redis.NewClient(opt)

        ctx := context.Background()
        if err := rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ö†Ô∏è Failed to connect to Redis: %v, continuing without Redis", err)
                rdb = nil
                return
        }</span>

        <span class="cov0" title="0">log.Println("‚úÖ Successfully connected to Redis")</span>
}

// =============================================================================
// üö¶ MIDDLEWARE
// =============================================================================

// rateLimitMiddleware implements rate limiting (100 requests per minute)
func rateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()

                rateLimitMutex.Lock()
                now := time.Now()

                // üßπ Clean old requests (older than 1 minute)
                var validRequests []time.Time
                for _, reqTime := range rateLimitMap[clientIP] </span><span class="cov0" title="0">{
                        if now.Sub(reqTime) &lt; time.Minute </span><span class="cov0" title="0">{
                                validRequests = append(validRequests, reqTime)
                        }</span>
                }
                <span class="cov0" title="0">rateLimitMap[clientIP] = validRequests

                // üö´ Check rate limit (100 requests per minute)
                if len(rateLimitMap[clientIP]) &gt;= 100 </span><span class="cov0" title="0">{
                        rateLimitMutex.Unlock()
                        respondWithError(c, http.StatusTooManyRequests, "Rate limit exceeded. Please try again later.")
                        c.Abort()
                        return
                }</span>

                // ‚ûï Add current request
                <span class="cov0" title="0">rateLimitMap[clientIP] = append(rateLimitMap[clientIP], now)
                rateLimitMutex.Unlock()

                c.Next()</span>
        }
}

// prometheusMiddleware records metrics for all requests
func prometheusMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                path := c.FullPath()
                if path == "" </span><span class="cov0" title="0">{
                        path = c.Request.URL.Path
                }</span>
                <span class="cov0" title="0">method := c.Request.Method

                timer := prometheus.NewTimer(prometheus.ObserverFunc(func(v float64) </span><span class="cov0" title="0">{
                        httpRequestDuration.WithLabelValues(path, method, fmt.Sprint(c.Writer.Status())).Observe(v)
                }</span>))
                <span class="cov0" title="0">c.Next()
                timer.ObserveDuration()

                httpRequestsTotal.WithLabelValues(path, method, fmt.Sprint(c.Writer.Status())).Inc()</span>
        }
}

// =============================================================================
// üéØ API HANDLERS
// =============================================================================

// getProjects returns active projects
func getProjects(c *gin.Context) <span class="cov0" title="0">{
        // tracer := otel.Tracer("bruno-api")
        // ctx, span := tracer.Start(c.Request.Context(), "getProjects")
        // defer span.End()
        ctx := c.Request.Context()

        // üóÑÔ∏è Try cache first
        if cached, found := getFromCache[[]Project](ctx, "projects"); found </span><span class="cov0" title="0">{
                // span.AddEvent("cache_hit")
                respondWithETag(c, cached, http.StatusOK)
                return
        }</span>

        // span.AddEvent("cache_miss")

        // üóÉÔ∏è Query database
        <span class="cov0" title="0">query := `
                SELECT id, title, description, description as short_description, type, modules, github_url, live_url, image_url as video_url, technologies, active
                FROM projects 
                WHERE active = true
                ORDER BY "order" ASC, id ASC
        `
        log.Printf("üîç Executing query: %s", query)

        rows, err := db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå Database query failed: %v", err)
                // span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to fetch projects")
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var projects []Project
        for rows.Next() </span><span class="cov0" title="0">{
                var p Project
                var githubURL, liveURL sql.NullString
                var videoURL sql.NullString
                var technologies pq.StringArray
                if err := rows.Scan(&amp;p.ID, &amp;p.Title, &amp;p.Description, &amp;p.ShortDescription, &amp;p.Type, &amp;p.Modules, &amp;githubURL, &amp;liveURL, &amp;videoURL, &amp;technologies, &amp;p.Active); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                // üîó Use live_url if available, otherwise use github_url
                <span class="cov0" title="0">if liveURL.Valid </span><span class="cov0" title="0">{
                        p.URL = liveURL.String
                }</span> else<span class="cov0" title="0"> if githubURL.Valid </span><span class="cov0" title="0">{
                        p.URL = githubURL.String
                }</span>
                <span class="cov0" title="0">if videoURL.Valid </span><span class="cov0" title="0">{
                        p.VideoURL = videoURL.String
                }</span>
                // Set technologies
                <span class="cov0" title="0">p.Technologies = []string(technologies)
                projects = append(projects, p)</span>
        }

        // üóÑÔ∏è Cache the result
        <span class="cov0" title="0">setCache(ctx, "projects", projects, 5*time.Minute)

        // span.SetAttributes(semconv.DBStatement("SELECT projects"))
        respondWithETag(c, projects, http.StatusOK)</span>
}

// getAllProjects returns all projects (including inactive) for admin
func getAllProjects(c *gin.Context) <span class="cov0" title="0">{
        // tracer := otel.Tracer("bruno-api")
        // ctx, span := tracer.Start(c.Request.Context(), "getAllProjects")
        // defer span.End()
        ctx := c.Request.Context()

        query := `
                SELECT id, title, description, description as short_description, type, modules, github_url, live_url, image_url as video_url, technologies, active
                FROM projects 
                ORDER BY "order" ASC, id ASC
        `
        log.Printf("üîç getAllProjects: Executing query: %s", query)

        rows, err := db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå getAllProjects: Database query failed: %v", err)
                // span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to fetch projects")
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var projects []Project
        for rows.Next() </span><span class="cov0" title="0">{
                var p Project
                var githubURL, liveURL sql.NullString
                var videoURL sql.NullString
                var technologies pq.StringArray
                if err := rows.Scan(&amp;p.ID, &amp;p.Title, &amp;p.Description, &amp;p.ShortDescription, &amp;p.Type, &amp;p.Modules, &amp;githubURL, &amp;liveURL, &amp;videoURL, &amp;technologies, &amp;p.Active); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if liveURL.Valid </span><span class="cov0" title="0">{
                        p.URL = liveURL.String
                }</span> else<span class="cov0" title="0"> if githubURL.Valid </span><span class="cov0" title="0">{
                        p.URL = githubURL.String
                }</span>
                <span class="cov0" title="0">if videoURL.Valid </span><span class="cov0" title="0">{
                        p.VideoURL = videoURL.String
                }</span>
                // Set technologies
                <span class="cov0" title="0">p.Technologies = []string(technologies)
                projects = append(projects, p)</span>
        }

        <span class="cov0" title="0">log.Printf("üîç getAllProjects: Found %d projects", len(projects))

        // span.SetAttributes(semconv.DBStatement("SELECT all projects"))
        respondWithSuccess(c, gin.H{
                "projects": projects,
                "total":    len(projects),
                "active":   countActiveProjects(projects),
                "inactive": countInactiveProjects(projects),
        })</span>
}

// activateProject activates a project
func activateProject(c *gin.Context) <span class="cov0" title="0">{
        // tracer := otel.Tracer("bruno-api")
        // ctx, span := tracer.Start(c.Request.Context(), "activateProject")
        // defer span.End()
        ctx := c.Request.Context()

        projectID := c.Param("id")
        if projectID == "" </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusBadRequest, "Project ID is required")
                return
        }</span>

        <span class="cov0" title="0">result, err := execWithTracing(ctx, "bruno-api", "activate_project", "UPDATE projects SET active = true WHERE id = $1", projectID)
        if err != nil </span><span class="cov0" title="0">{
                // span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to activate project")
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusNotFound, "Project not found")
                return
        }</span>

        <span class="cov0" title="0">clearCache(ctx, "projects")
        // span.AddEvent("project_activated")
        respondWithSuccess(c, gin.H{
                "message":    "Project activated successfully",
                "project_id": projectID,
        })</span>
}

// deactivateProject deactivates a project
func deactivateProject(c *gin.Context) <span class="cov0" title="0">{
        tracer := otel.Tracer("portfolio-api")
        ctx, span := tracer.Start(c.Request.Context(), "deactivateProject")
        defer span.End()

        projectID := c.Param("id")
        if projectID == "" </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusBadRequest, "Project ID is required")
                return
        }</span>

        <span class="cov0" title="0">result, err := execWithTracing(ctx, "portfolio-api", "deactivate_project", "UPDATE projects SET active = false WHERE id = $1", projectID)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to deactivate project")
                return
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusNotFound, "Project not found")
                return
        }</span>

        <span class="cov0" title="0">clearCache(ctx, "projects")
        span.AddEvent("project_deactivated")
        respondWithSuccess(c, gin.H{
                "message":    "Project deactivated successfully",
                "project_id": projectID,
        })</span>
}

// getProjectStats returns project statistics
func getProjectStats(c *gin.Context) <span class="cov0" title="0">{
        tracer := otel.Tracer("portfolio-api")
        ctx, span := tracer.Start(c.Request.Context(), "getProjectStats")
        defer span.End()

        var total, active int
        err := queryRowWithTracing(ctx, "portfolio-api", "project_stats_total", "SELECT COUNT(*) FROM projects", &amp;total)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to get project stats")
                return
        }</span>

        <span class="cov0" title="0">err = queryRowWithTracing(ctx, "portfolio-api", "project_stats_active", "SELECT COUNT(*) FROM projects WHERE active = true", &amp;active)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to get active project count")
                return
        }</span>

        <span class="cov0" title="0">inactive := total - active
        respondWithSuccess(c, gin.H{
                "total":             total,
                "active":            active,
                "inactive":          inactive,
                "active_percentage": float64(active) / float64(total) * 100,
        })</span>
}

// getAbout returns about page data
func getAbout(c *gin.Context) <span class="cov0" title="0">{
        ctx := context.Background()

        // üóÑÔ∏è Try cache first
        if cached, found := getFromCache[AboutData](ctx, "about"); found </span><span class="cov0" title="0">{
                respondWithSuccess(c, cached)
                return
        }</span>

        <span class="cov0" title="0">var description string
        err := db.QueryRowContext(ctx, "SELECT value-&gt;&gt;'description' FROM content WHERE key = 'about'").Scan(&amp;description)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusInternalServerError, "Failed to fetch about data")
                return
        }</span>

        <span class="cov0" title="0">aboutData := AboutData{
                Description: description,
                Highlights: []struct {
                        Icon string `json:"icon"`
                        Text string `json:"text"`
                }{}, // TODO: Implement proper JSON parsing for highlights
        }

        setCache(ctx, "about", aboutData, 10*time.Minute)
        respondWithSuccess(c, aboutData)</span>
}

// getContact returns contact information
func getContact(c *gin.Context) <span class="cov0" title="0">{
        ctx := context.Background()

        // üóÑÔ∏è Try cache first
        if cached, found := getFromCache[ContactData](ctx, "contact"); found </span><span class="cov0" title="0">{
                respondWithSuccess(c, cached)
                return
        }</span>

        <span class="cov0" title="0">contactData := ContactData{
                Email:        getContentValue(ctx, "contact", "email", "bruno@lucena.cloud"),
                Location:     getContentValue(ctx, "contact", "location", "Brazil"),
                LinkedIn:     getContentValue(ctx, "contact", "linkedin", "https://www.linkedin.com/in/bvlucena"),
                GitHub:       getContentValue(ctx, "contact", "github", "https://github.com/brunovlucena"),
                Availability: getContentValue(ctx, "contact", "availability", "Open to new opportunities in SRE, DevSecOps, and AI Engineering roles."),
        }

        setCache(ctx, "contact", contactData, 10*time.Minute)
        respondWithSuccess(c, contactData)</span>
}

// getSkills returns technical skills
func getSkills(c *gin.Context) <span class="cov0" title="0">{
        tracer := otel.Tracer("portfolio-api")
        ctx, span := tracer.Start(c.Request.Context(), "getSkills")
        defer span.End()

        // üóÑÔ∏è Try cache first
        if cached, found := getFromCache[[]Skill](ctx, "skills"); found </span><span class="cov0" title="0">{
                span.AddEvent("cache_hit")
                respondWithETag(c, cached, http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, `
                SELECT id, name, category, proficiency, icon, "order" 
                FROM skills 
                ORDER BY "order", name
        `)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to fetch skills")
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var skills []Skill
        for rows.Next() </span><span class="cov0" title="0">{
                var skill Skill
                err := rows.Scan(&amp;skill.ID, &amp;skill.Name, &amp;skill.Category, &amp;skill.Proficiency, &amp;skill.Icon, &amp;skill.Order)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        continue</span>
                }
                <span class="cov0" title="0">skills = append(skills, skill)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to scan skills")
                return
        }</span>

        <span class="cov0" title="0">setCache(ctx, "skills", skills, 5*time.Minute)
        respondWithETag(c, skills, http.StatusOK)</span>
}

// getExperience returns work experience
func getExperience(c *gin.Context) <span class="cov0" title="0">{
        tracer := otel.Tracer("portfolio-api")
        ctx, span := tracer.Start(c.Request.Context(), "getExperience")
        defer span.End()

        // üóÑÔ∏è Try cache first
        if cached, found := getFromCache[[]Experience](ctx, "experience"); found </span><span class="cov0" title="0">{
                span.AddEvent("cache_hit")
                respondWithETag(c, cached, http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">rows, err := db.QueryContext(ctx, `
                SELECT id, title, company, start_date, end_date, current, description, technologies, "order" 
                FROM experience 
                ORDER BY "order" DESC, start_date DESC
        `)
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to fetch experience")
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var experience []Experience
        for rows.Next() </span><span class="cov0" title="0">{
                var exp Experience
                var technologiesJSON []byte
                err := rows.Scan(&amp;exp.ID, &amp;exp.Title, &amp;exp.Company, &amp;exp.StartDate, &amp;exp.EndDate, &amp;exp.Current, &amp;exp.Description, &amp;technologiesJSON, &amp;exp.Order)
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        continue</span>
                }

                <span class="cov0" title="0">if err := json.Unmarshal(technologiesJSON, &amp;exp.Technologies); err != nil </span><span class="cov0" title="0">{
                        exp.Technologies = []string{}
                }</span>

                <span class="cov0" title="0">experience = append(experience, exp)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
                respondWithError(c, http.StatusInternalServerError, "Failed to scan experience")
                return
        }</span>

        <span class="cov0" title="0">setCache(ctx, "experience", experience, 5*time.Minute)
        respondWithETag(c, experience, http.StatusOK)</span>
}

// trackVisit tracks visitor analytics
func trackVisit(c *gin.Context) <span class="cov0" title="0">{
        var visit struct {
                IP        string `json:"ip"`
                UserAgent string `json:"user_agent"`
                Referrer  string `json:"referrer"`
        }

        if err := c.ShouldBindJSON(&amp;visit); err != nil </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if visit.IP == "" </span><span class="cov0" title="0">{
                visit.IP = c.ClientIP()
        }</span>

        <span class="cov0" title="0">if !isValidIP(visit.IP) </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusBadRequest, "Invalid IP address format")
                return
        }</span>

        <span class="cov0" title="0">visit.UserAgent = sanitizeString(visit.UserAgent)
        visit.Referrer = sanitizeString(visit.Referrer)

        if visit.Referrer != "" &amp;&amp; !validateURL(visit.Referrer) </span><span class="cov0" title="0">{
                respondWithError(c, http.StatusBadRequest, "Invalid referrer URL")
                return
        }</span>

        <span class="cov0" title="0">_, err := db.ExecContext(c.Request.Context(), `
                INSERT INTO visitors (ip, user_agent, first_visit, last_visit, visit_count)
                VALUES ($1, $2, NOW(), NOW(), 1)
                ON CONFLICT (ip) DO UPDATE SET
                        last_visit = NOW(),
                        visit_count = visitors.visit_count + 1
        `, visit.IP, visit.UserAgent)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ùå Failed to store analytics: %v", err)
                respondWithError(c, http.StatusInternalServerError, "Failed to track visit")
                return
        }</span>

        <span class="cov0" title="0">respondWithSuccess(c, gin.H{"status": "success"})</span>
}

// =============================================================================
// üöÄ MAIN APPLICATION
// =============================================================================

func main() <span class="cov0" title="0">{
        // üîß Load environment variables
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Println("‚ÑπÔ∏è No .env file found, using environment variables")
        }</span>

        // üîç Initialize OpenTelemetry tracing - DISABLED
        // tp, err := initTracer()
        // if err != nil {
        //         log.Printf("‚ö†Ô∏è Failed to initialize tracer: %v", err)
        // } else {
        //         defer func() {
        //                 if err := tp.Shutdown(context.Background()); err != nil {
        //                         log.Printf("‚ùå Error shutting down tracer provider: %v", err)
        //                 }
        //         }()
        // }

        // üóÑÔ∏è Initialize database and Redis
        <span class="cov0" title="0">initDB()
        defer db.Close()

        initRedis()
        if rdb != nil </span><span class="cov0" title="0">{
                defer rdb.Close()
        }</span>

        // üåê Set up Gin router
        <span class="cov0" title="0">gin.SetMode(gin.ReleaseMode)
        r := gin.Default()

        // üîß Add middleware
        r.Use(gzip.Gzip(gzip.DefaultCompression))
        r.Use(prometheusMiddleware())
        // r.Use(otelgin.Middleware("portfolio-api")) // DISABLED

        // üåç Configure CORS
        config := cors.DefaultConfig()
        config.AllowOrigins = []string{"http://localhost:3000", "http://localhost:5173", "http://localhost:8080", "*"}
        config.AllowMethods = []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}
        config.AllowHeaders = []string{"Origin", "Content-Type", "Accept", "Authorization"}
        config.ExposeHeaders = []string{"Content-Length"}
        config.AllowCredentials = true
        config.MaxAge = 12 * time.Hour
        r.Use(cors.New(config))

        // üè• Health check endpoint
        r.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                respondWithSuccess(c, gin.H{"status": "ok"})
        }</span>)

        // üìä Prometheus metrics endpoint
        <span class="cov0" title="0">r.GET("/metrics", gin.WrapH(promhttp.Handler()))

        // üéØ API routes with rate limiting
        v1 := r.Group("/v1")
        </span><span class="cov0" title="0">{
                v1.GET("/projects", rateLimitMiddleware(), getProjects)
                v1.GET("/about", rateLimitMiddleware(), getAbout)
                v1.GET("/contact", rateLimitMiddleware(), getContact)
                v1.GET("/content/skills", rateLimitMiddleware(), getSkills)
                v1.GET("/content/experience", rateLimitMiddleware(), getExperience)
                v1.POST("/analytics/visit", rateLimitMiddleware(), trackVisit)
        }</span>

        // üëë Admin routes for project management
        <span class="cov0" title="0">admin := r.Group("/admin")
        </span><span class="cov0" title="0">{
                admin.GET("/projects", rateLimitMiddleware(), getAllProjects)
                admin.PUT("/projects/:id/activate", rateLimitMiddleware(), activateProject)
                admin.PUT("/projects/:id/deactivate", rateLimitMiddleware(), deactivateProject)
                admin.GET("/projects/stats", rateLimitMiddleware(), getProjectStats)
        }</span>

        // üöÄ Start server
        <span class="cov0" title="0">port := getEnv("PORT", "8080")
        log.Printf("üöÄ Starting Bruno API server on port %s", port)
        if err := r.Run(":" + port); err != nil </span><span class="cov0" title="0">{
                log.Fatal("‚ùå Failed to start server:", err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
